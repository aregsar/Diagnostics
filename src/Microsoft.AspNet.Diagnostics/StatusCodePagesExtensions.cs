// Copyright (c) Microsoft Open Technologies, Inc. All rights reserved.
// Licensed under the Apache License, Version 2.0. See License.txt in the project root for license information.

using System;
using System.Globalization;
using System.Threading.Tasks;
using Microsoft.AspNet.Diagnostics;
using Microsoft.AspNet.Http;

namespace Microsoft.AspNet.Builder
{
    public static class StatusCodePagesExtensions
    {
        /// <summary>
        /// Adds a middleware that checks for responses with status codes between 400 and 599 that do not
        /// have a body. Several approaches can be used to generate the response body.
        /// </summary>
        /// <param name="app"></param>
        /// <param name="options"></param>
        /// <returns></returns>
        public static IApplicationBuilder UseStatusCodePages(this IApplicationBuilder app, StatusCodePagesOptions options)
        {
            return app.UseMiddleware<StatusCodePagesMiddleware>(options);
        }

        /// <summary>
        /// Specifies the handler to invoke to generate the response body.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="handler"></param>
        /// <returns></returns>
        public static StatusCodePagesOptions WithHandler(this StatusCodePagesOptions options, Func<StatusCodeContext, Task> handler)
        {
            options.HandleAsync = handler;
            return options;
        }

        /// <summary>
        /// Specifies the response body to send. This may include a '{0}' placeholder for the status code.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="contentType"></param>
        /// <param name="bodyFormat"></param>
        /// <returns></returns>
        public static StatusCodePagesOptions WithResponse(this StatusCodePagesOptions options, string contentType, string bodyFormat)
        {
            return options.WithHandler(context =>
            {
                var body = string.Format(CultureInfo.InvariantCulture, bodyFormat, context.HttpContext.Response.StatusCode);
                return context.HttpContext.Response.SendAsync(body, contentType);
            });
        }

        /// <summary>
        /// Specifies that responses should be handled by redirecting with the given location url template.
        /// This may include a '{0}' placeholder for the status code. Ulrs starting with '~' will have PathBase prepeneded,
        /// where any other url will be used as is.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="locationFormat"></param>
        /// <returns></returns>
        public static StatusCodePagesOptions WithRedirect(this StatusCodePagesOptions options, string locationFormat)
        {
            if (locationFormat.StartsWith("~"))
            {
                locationFormat = locationFormat.Substring(1);
                return options.WithHandler(context =>
                {
                    var location = string.Format(CultureInfo.InvariantCulture, locationFormat, context.HttpContext.Response.StatusCode);
                    context.HttpContext.Response.Redirect(context.HttpContext.Request.PathBase + location);
                    return Task.FromResult(0);
                });
            }
            else
            {
                return options.WithHandler(context =>
                {
                    var location = string.Format(CultureInfo.InvariantCulture, locationFormat, context.HttpContext.Response.StatusCode);
                    context.HttpContext.Response.Redirect(location);
                    return Task.FromResult(0);
                });
            }
        }

        /// <summary>
        /// Specifies an alternate middleware pipeline to execute to generate the response body.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="configuration"></param>
        /// <returns></returns>
        public static StatusCodePagesOptions WithTangent(this StatusCodePagesOptions options, Action<IApplicationBuilder> configuration)
        {
            var builder = new ApplicationBuilder(serviceProvider: null); // TODO: services
            configuration(builder);
            var tangent = builder.Build();
            return options.WithHandler(context => tangent(context.HttpContext));
        }

        /// <summary>
        /// Specifies that the response body should be generated by re-executing the request pipeline using an alternate path.
        /// This path may contain a '{0}' placeholder of the status code.
        /// </summary>
        /// <param name="options"></param>
        /// <param name="pathFormat"></param>
        /// <returns></returns>
        public static StatusCodePagesOptions WithReExecute(this StatusCodePagesOptions options, string pathFormat)
        {
            return options.WithHandler(async context =>
            {
                var newPath = new PathString(string.Format(CultureInfo.InvariantCulture, pathFormat, context.HttpContext.Response.StatusCode));

                var originalPath = context.HttpContext.Request.Path;
                // Store the original paths so the app can check it.
                context.HttpContext.SetFeature<IStatusCodeReExecuteFeature>(new StatusCodeReExecuteFeature()
                {
                    OriginalPathBase = context.HttpContext.Request.PathBase.Value,
                    OriginalPath = originalPath.Value,
                });

                context.HttpContext.Request.Path = newPath;
                try
                {
                    await context.Next(context.HttpContext);
                }
                finally
                {
                    context.HttpContext.Request.Path = originalPath;
                    context.HttpContext.SetFeature<IStatusCodeReExecuteFeature>(null);
                }
            });
        }
    }
}